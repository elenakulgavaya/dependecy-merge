{"name": "test_save_roi_calculator_user", "status": "broken", "statusDetails": {"message": "sqlalchemy.exc.ProgrammingError: (MySQLdb._exceptions.ProgrammingError) (1146, \"Table 'enduser.RoiCalculatorUsers' doesn't exist\")\n[SQL: SELECT `RoiCalculatorUsers`.id AS `RoiCalculatorUsers_id`, `RoiCalculatorUsers`.email AS `RoiCalculatorUsers_email`, `RoiCalculatorUsers`.`firstName` AS `RoiCalculatorUsers_firstName`, `RoiCalculatorUsers`.`lastName` AS `RoiCalculatorUsers_lastName`, `RoiCalculatorUsers`.`companyName` AS `RoiCalculatorUsers_companyName`, `RoiCalculatorUsers`.`createTime` AS `RoiCalculatorUsers_createTime` \nFROM `RoiCalculatorUsers` \nWHERE `RoiCalculatorUsers`.email = %s]\n[parameters: ('rebecca00@example.com',)]\n(Background on this error at: https://sqlalche.me/e/14/f405)", "trace": "self = <sqlalchemy.engine.base.Connection object at 0x1042f67f0>\ndialect = <sqlalchemy.dialects.mysql.mysqldb.MySQLDialect_mysqldb object at 0x103f2df70>\nconstructor = <bound method DefaultExecutionContext._init_compiled of <class 'sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb'>>\nstatement = 'SELECT `RoiCalculatorUsers`.id AS `RoiCalculatorUsers_id`, `RoiCalculatorUsers`.email AS `RoiCalculatorUsers_email`, ...s`.`createTime` AS `RoiCalculatorUsers_createTime` \\nFROM `RoiCalculatorUsers` \\nWHERE `RoiCalculatorUsers`.email = %s'\nparameters = ('rebecca00@example.com',)\nexecution_options = immutabledict({'_sa_orm_load_options': default_load_options(_legacy_uniquing=True), '_result_disable_adapt_to_context': True, 'future_result': True})\nargs = (<sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x1042795e0>, [{}], <sqlalchemy.sql.selectable.Select object at 0x104279130>, [BindParameter('%(4364670336 email)s', 'rebecca00@example.com', type_=VARCHAR(length=255))])\nkw = {'cache_hit': symbol('CACHE_MISS')}, branched = <sqlalchemy.engine.base.Connection object at 0x1042f67f0>\nconn = <sqlalchemy.pool.base._ConnectionFairy object at 0x1042f0610>\ncontext = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x104279bb0>\ncursor = <MySQLdb.cursors.Cursor object at 0x104279970>, evt_handled = False\n\n    def _execute_context(\n        self,\n        dialect,\n        constructor,\n        statement,\n        parameters,\n        execution_options,\n        *args,\n        **kw\n    ):\n        \"\"\"Create an :class:`.ExecutionContext` and execute, returning\n        a :class:`_engine.CursorResult`.\"\"\"\n    \n        branched = self\n        if self.__branch_from:\n            # if this is a \"branched\" connection, do everything in terms\n            # of the \"root\" connection, *except* for .close(), which is\n            # the only feature that branching provides\n            self = self.__branch_from\n    \n        try:\n            conn = self._dbapi_connection\n            if conn is None:\n                conn = self._revalidate_connection()\n    \n            context = constructor(\n                dialect, self, conn, execution_options, *args, **kw\n            )\n        except (exc.PendingRollbackError, exc.ResourceClosedError):\n            raise\n        except BaseException as e:\n            self._handle_dbapi_exception(\n                e, util.text_type(statement), parameters, None, None\n            )\n    \n        if (\n            self._transaction\n            and not self._transaction.is_active\n            or (\n                self._nested_transaction\n                and not self._nested_transaction.is_active\n            )\n        ):\n            self._invalid_transaction()\n    \n        elif self._trans_context_manager:\n            TransactionalContext._trans_ctx_check(self)\n    \n        if self._is_future and self._transaction is None:\n            self._autobegin()\n    \n        context.pre_exec()\n    \n        if dialect.use_setinputsizes:\n            context._set_input_sizes()\n    \n        cursor, statement, parameters = (\n            context.cursor,\n            context.statement,\n            context.parameters,\n        )\n    \n        if not context.executemany:\n            parameters = parameters[0]\n    \n        if self._has_events or self.engine._has_events:\n            for fn in self.dispatch.before_cursor_execute:\n                statement, parameters = fn(\n                    self,\n                    cursor,\n                    statement,\n                    parameters,\n                    context,\n                    context.executemany,\n                )\n    \n        if self._echo:\n    \n            self._log_info(statement)\n    \n            stats = context._get_cache_stats()\n    \n            if not self.engine.hide_parameters:\n                self._log_info(\n                    \"[%s] %r\",\n                    stats,\n                    sql_util._repr_params(\n                        parameters, batches=10, ismulti=context.executemany\n                    ),\n                )\n            else:\n                self._log_info(\n                    \"[%s] [SQL parameters hidden due to hide_parameters=True]\"\n                    % (stats,)\n                )\n    \n        evt_handled = False\n        try:\n            if context.executemany:\n                if self.dialect._has_events:\n                    for fn in self.dialect.dispatch.do_executemany:\n                        if fn(cursor, statement, parameters, context):\n                            evt_handled = True\n                            break\n                if not evt_handled:\n                    self.dialect.do_executemany(\n                        cursor, statement, parameters, context\n                    )\n            elif not parameters and context.no_parameters:\n                if self.dialect._has_events:\n                    for fn in self.dialect.dispatch.do_execute_no_params:\n                        if fn(cursor, statement, context):\n                            evt_handled = True\n                            break\n                if not evt_handled:\n                    self.dialect.do_execute_no_params(\n                        cursor, statement, context\n                    )\n            else:\n                if self.dialect._has_events:\n                    for fn in self.dialect.dispatch.do_execute:\n                        if fn(cursor, statement, parameters, context):\n                            evt_handled = True\n                            break\n                if not evt_handled:\n>                   self.dialect.do_execute(\n                        cursor, statement, parameters, context\n                    )\n\n.venv/lib/python3.9/site-packages/sqlalchemy/engine/base.py:1802: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <sqlalchemy.dialects.mysql.mysqldb.MySQLDialect_mysqldb object at 0x103f2df70>\ncursor = <MySQLdb.cursors.Cursor object at 0x104279970>\nstatement = 'SELECT `RoiCalculatorUsers`.id AS `RoiCalculatorUsers_id`, `RoiCalculatorUsers`.email AS `RoiCalculatorUsers_email`, ...s`.`createTime` AS `RoiCalculatorUsers_createTime` \\nFROM `RoiCalculatorUsers` \\nWHERE `RoiCalculatorUsers`.email = %s'\nparameters = ('rebecca00@example.com',)\ncontext = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x104279bb0>\n\n    def do_execute(self, cursor, statement, parameters, context=None):\n>       cursor.execute(statement, parameters)\n\n.venv/lib/python3.9/site-packages/sqlalchemy/engine/default.py:732: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <MySQLdb.cursors.Cursor object at 0x104279970>\nquery = b\"SELECT `RoiCalculatorUsers`.id AS `RoiCalculatorUsers_id`, `RoiCalculatorUsers`.email AS `RoiCalculatorUsers_email`,...oiCalculatorUsers_createTime` \\nFROM `RoiCalculatorUsers` \\nWHERE `RoiCalculatorUsers`.email = 'rebecca00@example.com'\"\nargs = (b\"'rebecca00@example.com'\",)\n\n    def execute(self, query, args=None):\n        \"\"\"Execute a query.\n    \n        query -- string, query to execute on server\n        args -- optional sequence or mapping, parameters to use with query.\n    \n        Note: If args is a sequence, then %s must be used as the\n        parameter placeholder in the query. If a mapping is used,\n        %(key)s must be used as the placeholder.\n    \n        Returns integer represents rows affected, if any\n        \"\"\"\n        while self.nextset():\n            pass\n        db = self._get_db()\n    \n        if isinstance(query, str):\n            query = query.encode(db.encoding)\n    \n        if args is not None:\n            if isinstance(args, dict):\n                nargs = {}\n                for key, item in args.items():\n                    if isinstance(key, str):\n                        key = key.encode(db.encoding)\n                    nargs[key] = db.literal(item)\n                args = nargs\n            else:\n                args = tuple(map(db.literal, args))\n            try:\n                query = query % args\n            except TypeError as m:\n                raise ProgrammingError(str(m))\n    \n        assert isinstance(query, (bytes, bytearray))\n>       res = self._query(query)\n\n.venv/lib/python3.9/site-packages/MySQLdb/cursors.py:206: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <MySQLdb.cursors.Cursor object at 0x104279970>\nq = b\"SELECT `RoiCalculatorUsers`.id AS `RoiCalculatorUsers_id`, `RoiCalculatorUsers`.email AS `RoiCalculatorUsers_email`,...oiCalculatorUsers_createTime` \\nFROM `RoiCalculatorUsers` \\nWHERE `RoiCalculatorUsers`.email = 'rebecca00@example.com'\"\n\n    def _query(self, q):\n        db = self._get_db()\n        self._result = None\n>       db.query(q)\n\n.venv/lib/python3.9/site-packages/MySQLdb/cursors.py:319: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <_mysql.connection open to '0.0.0.0' at 0x11d817610>\nquery = b\"SELECT `RoiCalculatorUsers`.id AS `RoiCalculatorUsers_id`, `RoiCalculatorUsers`.email AS `RoiCalculatorUsers_email`,...oiCalculatorUsers_createTime` \\nFROM `RoiCalculatorUsers` \\nWHERE `RoiCalculatorUsers`.email = 'rebecca00@example.com'\"\n\n    def query(self, query):\n        # Since _mysql releases GIL while querying, we need immutable buffer.\n        if isinstance(query, bytearray):\n            query = bytes(query)\n>       _mysql.connection.query(self, query)\nE       MySQLdb._exceptions.ProgrammingError: (1146, \"Table 'enduser.RoiCalculatorUsers' doesn't exist\")\n\n.venv/lib/python3.9/site-packages/MySQLdb/connections.py:254: ProgrammingError\n\nThe above exception was the direct cause of the following exception:\n\n    def test_save_roi_calculator_user():\n        request = SaveRoiCalculatorUser().request().verify_response(error_code=500)\n>       roi_calculator_user_tbl.verify_created(request.req_body)\n\ntests/enduser/test_save_roi_calc_user.py:7: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nqa/db/enduser/roi_calculator_user_tbl.py:16: in verify_created\n    actual = get_for_email(req_body.Email.value)\nqa/db/enduser/roi_calculator_user_tbl.py:6: in get_for_email\n    return db.get_record(RoiCalculatorUser, email=email)\nqa/tools/db.py:171: in get_record\n    return self.get_records(model, *criteria, **kwargs)[0]\nqa/tools/db.py:191: in get_records\n    return wait(\n.venv/lib/python3.9/site-packages/waiting/__init__.py:18: in wait\n    for x in iterwait(result=result, *args, **kwargs):\n.venv/lib/python3.9/site-packages/waiting/__init__.py:44: in iterwait\n    result.result = predicate()\nqa/tools/db.py:186: in filter_records\n    for rec in self._get_records(\nqa/tools/db.py:165: in _get_records\n    data = query.filter_by(**kwargs).order_by(order_by).all()\n.venv/lib/python3.9/site-packages/sqlalchemy/orm/query.py:2759: in all\n    return self._iter().all()\n.venv/lib/python3.9/site-packages/sqlalchemy/orm/query.py:2894: in _iter\n    result = self.session.execute(\n.venv/lib/python3.9/site-packages/sqlalchemy/orm/session.py:1692: in execute\n    result = conn._execute_20(statement, params or {}, execution_options)\n.venv/lib/python3.9/site-packages/sqlalchemy/engine/base.py:1614: in _execute_20\n    return meth(self, args_10style, kwargs_10style, execution_options)\n.venv/lib/python3.9/site-packages/sqlalchemy/sql/elements.py:325: in _execute_on_connection\n    return connection._execute_clauseelement(\n.venv/lib/python3.9/site-packages/sqlalchemy/engine/base.py:1481: in _execute_clauseelement\n    ret = self._execute_context(\n.venv/lib/python3.9/site-packages/sqlalchemy/engine/base.py:1845: in _execute_context\n    self._handle_dbapi_exception(\n.venv/lib/python3.9/site-packages/sqlalchemy/engine/base.py:2026: in _handle_dbapi_exception\n    util.raise_(\n.venv/lib/python3.9/site-packages/sqlalchemy/util/compat.py:207: in raise_\n    raise exception\n.venv/lib/python3.9/site-packages/sqlalchemy/engine/base.py:1802: in _execute_context\n    self.dialect.do_execute(\n.venv/lib/python3.9/site-packages/sqlalchemy/engine/default.py:732: in do_execute\n    cursor.execute(statement, parameters)\n.venv/lib/python3.9/site-packages/MySQLdb/cursors.py:206: in execute\n    res = self._query(query)\n.venv/lib/python3.9/site-packages/MySQLdb/cursors.py:319: in _query\n    db.query(q)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <_mysql.connection open to '0.0.0.0' at 0x11d817610>\nquery = b\"SELECT `RoiCalculatorUsers`.id AS `RoiCalculatorUsers_id`, `RoiCalculatorUsers`.email AS `RoiCalculatorUsers_email`,...oiCalculatorUsers_createTime` \\nFROM `RoiCalculatorUsers` \\nWHERE `RoiCalculatorUsers`.email = 'rebecca00@example.com'\"\n\n    def query(self, query):\n        # Since _mysql releases GIL while querying, we need immutable buffer.\n        if isinstance(query, bytearray):\n            query = bytes(query)\n>       _mysql.connection.query(self, query)\nE       sqlalchemy.exc.ProgrammingError: (MySQLdb._exceptions.ProgrammingError) (1146, \"Table 'enduser.RoiCalculatorUsers' doesn't exist\")\nE       [SQL: SELECT `RoiCalculatorUsers`.id AS `RoiCalculatorUsers_id`, `RoiCalculatorUsers`.email AS `RoiCalculatorUsers_email`, `RoiCalculatorUsers`.`firstName` AS `RoiCalculatorUsers_firstName`, `RoiCalculatorUsers`.`lastName` AS `RoiCalculatorUsers_lastName`, `RoiCalculatorUsers`.`companyName` AS `RoiCalculatorUsers_companyName`, `RoiCalculatorUsers`.`createTime` AS `RoiCalculatorUsers_createTime` \nE       FROM `RoiCalculatorUsers` \nE       WHERE `RoiCalculatorUsers`.email = %s]\nE       [parameters: ('rebecca00@example.com',)]\nE       (Background on this error at: https://sqlalche.me/e/14/f405)\n\n.venv/lib/python3.9/site-packages/MySQLdb/connections.py:254: ProgrammingError"}, "start": 1648640668284, "stop": 1648640668661, "uuid": "e8eb31e2-6d0f-4c19-b9d7-07c17e91105c", "historyId": "91e2d5bb09f21f9be2198fa11cf99942", "testCaseId": "7bf574554b631fcd9e3354f2581bf06c", "fullName": "tests.enduser.test_save_roi_calc_user#test_save_roi_calculator_user", "labels": [{"name": "parentSuite", "value": "tests.enduser"}, {"name": "suite", "value": "test_save_roi_calc_user"}, {"name": "host", "value": "Elenas-MacBook-Pro.local"}, {"name": "thread", "value": "59719-MainThread"}, {"name": "framework", "value": "pytest"}, {"name": "language", "value": "cpython3"}, {"name": "package", "value": "tests.enduser.test_save_roi_calc_user"}]}